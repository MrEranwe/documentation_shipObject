<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: structure.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: structure.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @class 
Creates each object inside the ship. 
* @param {array} affiliations - Tags for classification of the objects. 
* @param {array} boxDimensions - Physical dimensions of the object.
* @param {array} weight - Weight of the object in specific loading condition.
* @param {array} cost - Monetary cost of the object.
* @param {array} capabilities - Specific characteristics of the object.
* @param {file} file - 2D, 3D file of the object.
* @example
baseObjects = {
  "Aerial4": {
      "affiliations": {"Deck": "WheelHouseTop", "Type": "Tank" ,"SFI": "806"},
      "boxDimensions": {
        "length": 10,
        "width": 3,
        "height":1
      },
      "weight": {
          "lightweight": {
              "mass": 400,
              "cg": [0,0,5]
          },
        
      },
	  "cost": {
		  "currency": "$",
		  "value": 5000,
	  },
      "capabilities": {
        "FluidDensity": "1025",
        "AreaRequired": "70",
        "VolRequired": "700",
      },
      "file3D": "aerial.stl"
  },
  
}



*/

baseObjects = {
  "Aerial4": {
      /** @memberof baseObjects# 
         * @constructs affiliations
         * @param {string} Deck - Deck where the object is located.
         * @param {string} Type - Type of object.
         * @param {string} SFI - Coding and classification system.
         */
      "affiliations": {"Deck": "WheelHouseTop", "Type": "Tank" ,"SFI": "806"},
      /** @memberof baseObjects# 
         * @constructs boxDimensions
         * @param {number} length - Lenght of the object.
         * @param {number} width - Width of the object.
         * @param {number} height - Height of the object.
         */
      "boxDimensions": {
        "length": 10,
        "width": 3,
        "height": 1
      },
      /** @memberof baseObjects#
         * @constructs weight 
         * @param {number} mass - Mass of the object in specific loading condition.
         * @param {array} cg - Coordinates of the cg of the object in specific loading condition.
         */
      "weight": {
          "lightweight": {
              "mass": 400,
              "cg": [0,0,5]
          },
        
      },
      /** @memberof baseObjects# 
         * @constructs cost
         * @param {string} currency - Currency.
         * @param {number} value - Cost of the object.
         */
	  "cost": {
		  "currency": "$",
		  "value": 5000,
	  },
      /** @memberof baseObjects# 
         * @constructs capabilities
         * @param {number} fluidDensity - Density of the fluid storaged in the object.
         * @param {number} areaRequired - Physical total area required for the disposition of the object.
         * @param {number} volRequired - Physical total volume required for the disposition of the object.
         */
      "capabilities": {
        "FluidDensity": "1025",
        "AreaRequired": "70",
        "VolRequired": "700",
      },
      "file3D": "aerial.stl"
  },
  
}
/** @class 
Class for the location of the objects inside the ship.
* @param {array} id - Id of the object. 
* @param {array} baseObject - Model of the object.
* @param {number} position - Coordinates of the object inside the ship.
* @param {array} weightState - ???
* @example 
objects = [
  {
    "id": "Aerial4",
    "baseObject": "Aerial",
    "position": {
          "xCentre": "64.5",
          "yCentre": "2.5",
          "zBase": "28.35"
    },
  	"weightState": "lightweight"
  },
  


]
*/
objects = [
  {
    "id": "Aerial4",
    "baseObject": "Aerial",
      /** @memberof objects# 
         * @constructs position
         * @param {number} xCentre - X coordinate of the centre of the object.
         * @param {number} yCentre - Y coordinate of the centre of the object.
         * @param {number} zBase - Z coordinate of the base of the object.
         */
    "position": {
          "xCentre": "64.5",
          "yCentre": "2.5",
          "zBase": "28.35"
    },
  	"weightState": "lightweight"
  },
  


]
/** @class 
Class for the calculations of the ship.
* @param {method} holtrop - Method used to estimate the resistance of displacement ships.
* @returns {holtrop}

*/
calculations = {

	"holtrop": {}
}
/** @class 
Specifies the variables inherents to the vessel.
* @param {array} attributes - Variables related to the physical dimensions of the ship.
* @param {array} hullOffsets - Table of offsets for the hull.
* @param {array} structure - Defines the decks and the bulkheads of the shio.
* @example
vessel= {
	"attributes": {
		"LOA":100, 
		"BOA":30,
		"Depth":12,
		"Draft_Design":6,
		"Airdraft_Design":5,
		"Freeboard_Design":6,
		"Cb_Design":0.85,
		"LWL_Design":90,
		"APP_Design":"",
		"FPP_Design":"",
		"camber":30,
	},
	"hullOffsets": {
		halfBreadths: {
			stations: [],
			waterlines: [],
			table: [[],[],[],[]]
		},
		buttockHeights: {}
	},
	"structure": {
		"decks": {
			"MainDeck": {
				"zFloor":6,
				"thickness":7,
				"xAft":0,
				"xFwd":90,
				"yCenter":0,
				"breadth":30,
				"density":6000
			},
		},
		"bulkheads": {
			"AB": {
				"xAft":12,
				"thickness":7,
				"density":6000
			}
		}
	}
}
*/
vessel= {
    /** @memberof vessel# 
         * @constructs attributes
         * @param {number} LOA - The maximum length of the ship
         * @param {number} BOA - The overall width of the ship measured at the widest point of the nominal waterline.
         * @param {number} Depth - Vertical distance measured from the top of the keel to the underside of the upper deck at side.
         * @param {number} Draft_Design - Desgin vertical distance from the bottom of the keel to the waterline.
         * @param {number} Airdraft_Design - Design distance from the surface of the water to the highest point on a vessel. 
         * @param {number} Freeboard_Design - Design depth plus the height of the keel structure minus draft.
         * @param {number} LWL_Design -  Design length at the waterline. Is the length from the forwardmost point of the waterline measured in profile to the stern-most point of the waterline.
         * @param {number} APP_Design -  ???
         * @param {number} FPP_Design -  ???
         * @param {number} camber -  Measure of lateral main deck curvature.
         
         */
	"attributes": {
		"LOA":100, 
		"BOA":30,
		"Depth":12,
		"Draft_Design":6,
		"Airdraft_Design":5,
		"Freeboard_Design":6,
		"Cb_Design":0.85,
		"LWL_Design":90,
		"APP_Design":"",
		"FPP_Design":"",
		"camber":30,
	},
	"hullOffsets": {
		halfBreadths: {
			stations: [],
			waterlines: [],
			table: [[],[],[],[]]
		},
		buttockHeights: {}
	},
        /** @memberof vessel# 
         * @constructs structure
         * @param {number} zFloor - Coordinate in z-axis of the floor of the deck.
         * @param {number} thickness - Thickness of the deck.
         * @param {number} xAft - Coordinate in x-axis of the closest point to the stern.
         * @param {number} xFwd - Coordinate in x-axis of the furthest  point to the stern.
         * @param {number} yCenter - Coordinate in y-axis of the center of the deck.
         * @param {number} breadth - Width of the deck.
         * @param {number} density -  Density of the material of the deck
         
         */
	"structure": {
		"decks": {
			"MainDeck": {
				"zFloor":6,
				"thickness":7,
				"xAft":0,
				"xFwd":90,
				"yCenter":0,
				"breadth":30,
				"density":6000
			},
		},
        /** @memberof vessel# 
         * @constructs bulkheads
         * @param {number} thickness - Thickness of the bulkhead.
         * @param {number} xAft - Coordinate in x-axis of the closest point to the stern.
         * @param {number} density -  Density of the material of the bulkhead.
         
         */
		"bulkheads": {
			"AB": {
				"xAft":12,
				"thickness":7,
				"density":6000
			}
		}
	}
}

/**
 * 
 * This Class define a propeller as well as its basic methods.
 * @class Propeller
     * Creates an instance of Propeller.
     * @param {Array} position -Position of the propeller in the vessel
     * @param {any} Diameter - Diameter of the propeller (m) 
     * @param {any} maxrpm - maximum allowed rotation per minute
     * @param {any} maxkw -maximum allowed power in kilowatts(kW)
     * @param {any} [rho] -Water Density. if not defined, 1025 is assumed
     * @param {any} [Ct]  - Propeller Coefficient, define its efficiency.if not defined, 1 is assumed
     * @example
     class Propeller{
      
    constructor(position,Diameter,maxrpm,maxkw,rho,Ct){
        this.maxkw = maxkw;
        this.maxrpm = maxrpm;
        if(typeof rho == 'undefined'){this.rho = 1025;}else{
        this.rho = rho;}
        this.Diameter = Diameter;
        this.x = position[0];
        this.y = position[1];
        this.z = position[2];
        if(typeof Ct == 'undefined'){this.Ct = 1;}else{
        this.Ct = Ct;
        }
    }
     
 */
class Propeller{
      
    constructor(position,Diameter,maxrpm,maxkw,rho,Ct){
        this.maxkw = maxkw;
        this.maxrpm = maxrpm;
        if(typeof rho == 'undefined'){this.rho = 1025;}else{
        this.rho = rho;}
        this.Diameter = Diameter;
        this.x = position[0];
        this.y = position[1];
        this.z = position[2];
        if(typeof Ct == 'undefined'){this.Ct = 1;}else{
        this.Ct = Ct;
        }
    }
    /**
     * 
     * This function returns the equivalent rpm for a given power input
     * @param {any} inputkw 
     * @returns {float} -the rotation of the propeller generated by the given power
     * @memberof Propeller
     * @example 
         kw2rpm(inputkw){
                     //Linear 
                    if(inputkw >= this.maxkw){
                        return this.maxkw;
                    }else{
                        return (inputkw*this.maxrpm)/(this.maxkw);
                    }

                }
     */
    kw2rpm(inputkw){
                     //Linear 
                    if(inputkw >= this.maxkw){
                        return this.maxkw;
                    }else{
                        return (inputkw*this.maxrpm)/(this.maxkw);
                    }

                }
    /**
     * This function returns the equivalent power needed for a given rotation
     * 
     * @param {any} inputrpm 
     * @returns {float} - the power needed  
     * @memberof Propeller
     * @example 
         rpm2kw(inputrpm){
                    if(inputrpm > this.maxrpm){
                        return this.maxrpm;
                    }else{
                        return (inputrpm*this.maxkw)/(this.maxkw);
                    }   
                }
    rpmsat(inputrpm){
                    if(Math.abs(inputrpm) > this.maxrpm){
                        return this.maxrpm;
                    }else return inputrpm;
                }
     */
    rpm2kw(inputrpm){
                    if(inputrpm > this.maxrpm){
                        return this.maxrpm;
                    }else{
                        return (inputrpm*this.maxkw)/(this.maxkw);
                    }   
                }
    rpmsat(inputrpm){
                    if(Math.abs(inputrpm) > this.maxrpm){
                        return this.maxrpm;
                    }else return inputrpm;
                }
    /**
     * 
     * Calculate the Trust generated by the rotation of the propeller
     * @param {any} inputrpm 
     * @returns {float} -Force generate by the given rpm
     * @memberof Propeller
     * @example 
     CalForce(inputrpm){

        if(inputrpm &lt; 0){
        return -(Math.pow(this.rpmsat(inputrpm),2)*Math.pow(this.Diameter,4)*(this.rho)*this.Ct);
        }
        return (Math.pow(this.rpmsat(inputrpm),2)*Math.pow(this.Diameter,4)*(this.rho)*this.Ct);


    }
     */
    CalForce(inputrpm){

        if(inputrpm &lt; 0){
        return -(Math.pow(this.rpmsat(inputrpm),2)*Math.pow(this.Diameter,4)*(this.rho)*this.Ct);
        }
        return (Math.pow(this.rpmsat(inputrpm),2)*Math.pow(this.Diameter,4)*(this.rho)*this.Ct);


    }

   /**
    * Reverse method of CalForce. Calculate the rotation needed to generate the given force
    * 
    * @param {any} trust - the force the propeller is causing (N)
    * @returns {float}  - the rotation needed (rpm)
    * @example 
       Force2rpm(trust){
        if(trust &lt; 0){
             return -(Math.sqrt(-trust/(this.rho*this.Ct))/(Math.pow(this.Diameter,2)));

        }else
            return (Math.sqrt(trust/(this.rho*this.Ct))/(Math.pow(this.Diameter,2)));

    }
    * @memberof Propeller
    */
   Force2rpm(trust){
        if(trust &lt; 0){
             return -(Math.sqrt(-trust/(this.rho*this.Ct))/(Math.pow(this.Diameter,2)));

        }else
            return (Math.sqrt(trust/(this.rho*this.Ct))/(Math.pow(this.Diameter,2)));

    }


}

/**
 * 
 * An configuration of marine propellers placed in pods that can be rotated to any horizontal angle (azimuth), making a rudder unnecessary.
 * These give ships better maneuverability than a fixed propeller and rudder system.
 * @class Azimuth
 * @extends {Propeller}
 * @example 
 class Azimuth extends Propeller {
    constructor(position,Diameter,maxrpm,maxkw,rho,Ct){
        super(position,Diameter,maxrpm,maxkw,rho,Ct);
    }
    getForces(inputrpm,angle){
        var F = this.CalForce(inputrpm);
        var Fy = F*Math.sin(angle);
        var Fx = F*Math.cos(angle);
        return [Fx,Fy,0];
    }
    getInputs([Fx,Fy,Fz]){
        var angle = Math.atan2(Fy,Fx);
        var F = Math.sqrt(Math.pow(Fx,2)+Math.pow(Fy,2));
        var rpm = this.Force2rpm(F);
        return [rpm,angle];

    }

}

 */
class Azimuth extends Propeller {
    constructor(position,Diameter,maxrpm,maxkw,rho,Ct){
        super(position,Diameter,maxrpm,maxkw,rho,Ct);
    }
    /**
     * 
     * 
     * @param {any} inputrpm 
     * @param {any} angle 
     * @returns {Array} - Forces in the Euler coordinate system x,y,z
     * @memberof Azimuth
     */
    getForces(inputrpm,angle){
        var F = this.CalForce(inputrpm);
        var Fy = F*Math.sin(angle);
        var Fx = F*Math.cos(angle);
        return [Fx,Fy,0];
    }
    /**
     * 
     * 
     * @param {any} [Fx,Fy,Fz] 
     * @returns {Array} - Return the rpm and angle need to this thruster to cause the given force
     * @memberof Azimuth
     */
    getInputs([Fx,Fy,Fz]){
        var angle = Math.atan2(Fy,Fx);
        var F = Math.sqrt(Math.pow(Fx,2)+Math.pow(Fy,2));
        var rpm = this.Force2rpm(F);
        return [rpm,angle];

    }

}

/**
 * 
 * Propellers of the craft mounted aft of the hull. Usually in conjunction with rudders. Produces forces only on x axis
 * @class MainPropeller
 * @extends {Propeller}
 * @example 
 class MainPropeller extends Propeller {
    constructor(position,Diameter,maxrpm,maxkw,rho,Ct,Rudder_Area){
        super(position,Diameter,maxrpm,maxkw,rho,Ct);
        if(typeof Rudder_Area != 'undefined'){
            this.AddRudder(Rudder_Area)
        }
        
        
    }

    AddRudder(Rudder_Area){
        this.Rudder = new Rudder([this.x,this.y,this.z],Rudder_Area,this.rho);
    }

    getForces(inputrpm,angle,speed){
            var Fy = 0;
        if(this.Rudder != 'undefined'){
            if(angle != 'undefined' &amp;&amp; speed != 'undefined'){
                Fy= this.Rudder.CalForce(angle,speed);
                Fy = Fy[1];
            }
        }
        var F = this.CalForce(inputrpm);
       
        return [F,Fy,0];
    }
    getInputs([Fx,Fy,Fz]){
        var angle = 0;
        var rpm = this.Force2rpm(Fx);
        return [rpm,angle];

    }

}
 */
class MainPropeller extends Propeller {
    constructor(position,Diameter,maxrpm,maxkw,rho,Ct,Rudder_Area){
        super(position,Diameter,maxrpm,maxkw,rho,Ct);
        if(typeof Rudder_Area != 'undefined'){
            this.AddRudder(Rudder_Area)
        }
        
        
    }
    /**
     * 
     * 
     * @param {any} Rudder_Area 
     * @memberof MainPropeller
     */
    AddRudder(Rudder_Area){
        this.Rudder = new Rudder([this.x,this.y,this.z],Rudder_Area,this.rho);
    }
    /**
     * 
     * 
     * @param {any} inputrpm 
     * @param {any} [angle] 
     * @param {any} [speed] 
     * @memberof MainPropeller
     */
    getForces(inputrpm,angle,speed){
            var Fy = 0;
        if(this.Rudder != 'undefined'){
            if(angle != 'undefined' &amp;&amp; speed != 'undefined'){
                Fy= this.Rudder.CalForce(angle,speed);
                Fy = Fy[1];
            }
        }
        var F = this.CalForce(inputrpm);
       
        return [F,Fy,0];
    }
    getInputs([Fx,Fy,Fz]){
        var angle = 0;
        var rpm = this.Force2rpm(Fx);
        return [rpm,angle];

    }

}

/**
 * Also called Manoeuvering thruster, bow thruster or stern thruster. 
 * they are transversal propulsion devices of the vessel.
 * 
 * @class TunnelThruster
 * @extends {Propeller}
 * @example 
 class TunnelThruster extends Propeller {
    constructor(position,Diameter,maxrpm,maxkw,rho,Ct){
        super(position,Diameter,maxrpm,maxkw,rho,Ct);
        
    }
    getForces(inputrpm,angle){
        var F = this.CalForce(inputrpm);
       
        return [0,F,0];
    }
    getInputs([Fx,Fy,Fz]){
        
        var angle = 0;
        var rpm = this.Force2rpm(Fy);
        return [rpm,angle];

    }

 */
class TunnelThruster extends Propeller {
    constructor(position,Diameter,maxrpm,maxkw,rho,Ct){
        super(position,Diameter,maxrpm,maxkw,rho,Ct);
        
    }
    /**
     * 
     * 
     * @param {any} inputrpm 
     * @param {any} angle 
     * @returns {Array} - Forces in the Euler coordinate system x,y,z
     * @memberof TunnelThruster
     */
    getForces(inputrpm,angle){
        var F = this.CalForce(inputrpm);
       
        return [0,F,0];
    }
    /**
     * 
     * 
     * @param {any} [Fx,Fy,Fz] 
     * @returns {Array} - Return the rpm and angle need to this thruster to cause the given force. Tunnel thruster always return angle =0
     * @memberof TunnelThruster
     */
    getInputs([Fx,Fy,Fz]){
        
        var angle = 0;
        var rpm = this.Force2rpm(Fy);
        return [rpm,angle];

    }

}

/**
 * 
 * 
 * @class Rudder
 * @example
 class Rudder{
    constructor(position,Area,rho){
        this.x = position[0];
        this.y = position[1];
        this.z = position[2];
        this.Area = Area;
        if(typeof rho == 'undefined'){
            this.rho = 1025;
        }else{this.rho = rho;}
    }
    CalForce(attackAngle,speed){
        var F = attackAngle*Math.PI*this.rho*Math.pow(speed,2)*this.Area
        return [0,F,0];
    }

}
 */
class Rudder{
    constructor(position,Area,rho){
        this.x = position[0];
        this.y = position[1];
        this.z = position[2];
        this.Area = Area;
        if(typeof rho == 'undefined'){
            this.rho = 1025;
        }else{this.rho = rho;}
    }
    /**
     * 
     * 
     * @param {any} attackAngle 
     * @param {any} speed 
     * @returns {Array} - Forces in the Euler coordinate system x,y,z
     * @memberof Rudder
     */
    CalForce(attackAngle,speed){
        var F = attackAngle*Math.PI*this.rho*Math.pow(speed,2)*this.Area
        return [0,F,0];
    }

}


/**
 * @method */
/**
 * Calculate the frequency response of the Ship based on the Jesen article "Estimation of ship motions using closed-form expressions"(January 2004)
 * @param {float} Length -Length of the Ship
 * @param {float} W_Breadth -Waterline Breadth(B0)
 * @param {float} Block  - Block coefficient
 * @param {float} Draft - Draft of the vessel
 * @param {float} Speed - relative speed of the vessel and the water in knot
 * @param {float} heading - heading of the wave
 * @param {float} Position -position of the wave from the center of gravity
 * @param {float} Wave_Amplitude - wave amplitude
 * @param {float} Cwp - Water plane coefficient
 * @param {float} GM - Metacentric Height
 * @param {float} natural_period - natural period of the Wave in seconds
 * @param {float} critical_damping_percentage - coeficient of the critical damping percentage
 * @param {float} delta - displacement of the vessel in kg
 * @return {Jensen} the Ship response for a group of frequency.

 *  */
function FreqResponseShipMotion (Length,W_Breadth,Block,Draft,Speed,heading,Position,Wave_Amplitude,Cwp,GM,natural_period,critical_damping_percentage,delta){
        
            var wave_freq = [];
            var Vertical_Movement=[];
            var Vertical_Acceleration=[];
            var Pitch_Movement=[];
            var Heave_Movement=[];
            var Bending_Moment=[];
            var Roll_Movement=[];
            var wave_period=[];
            
            //Vector declaration in the the main function -- They receive the properties and are used to plot the curves//
            var Results_array1=[];
			var Results_array2=[];
			var Results_array3=[];
			var Results_array4=[];
            var Results_array5=[]; 
            var Results_array6=[];
            var Results_array7=[];	
			
			//These constants and variables are prepared to be used inside the "for()" that calculates the vessels motion responses 
			g=9.81;	
			betha=heading*Math.PI/180;
			
			Breadth = W_Breadth*Block;
			Speed_metric=Speed*0.5144444;
			Froude_N=Speed_metric/Math.sqrt((g*Length));
			position=Length*Position/200;
			
			//This "for()" calculates the vessel responses to different waves frequencies//
						
			for (i = 0; i &lt;= 1000; i++){
                wave_freq[i]=0.05+1.95*i/1000;
                wave_number=Math.pow(wave_freq[i],2)/g;
                eff_wave_number=Math.abs(wave_number*Math.cos(betha));
                smith_factor=Math.exp(-wave_number*Draft);
                alpha=1-Froude_N*Math.sqrt(wave_number*Length)*Math.cos(betha);
                sectional_hydro_damping=2*Math.sin(0.5*wave_number*Breadth*Math.pow(alpha,2))*Math.exp(-wave_number*Draft*Math.pow(alpha,2));
                a=Math.pow(1-wave_number*Draft,2);
                b=Math.pow((Math.pow(sectional_hydro_damping,2)/(wave_number*Breadth*Math.pow(alpha,3))),2);
                f=Math.sqrt(a+b);
                F=smith_factor*f*(2/(eff_wave_number*Length))*Math.sin(eff_wave_number*Length/2);
                G=smith_factor*f*(24/(Math.pow(eff_wave_number*Length,2)*Length))*(Math.sin(eff_wave_number*Length/2)-(eff_wave_number*Length/2)*Math.cos(eff_wave_number*Length/2));
                eta=1/(Math.sqrt(Math.pow((1-2*wave_number*Draft*Math.pow(alpha,2)),2)+Math.pow(Math.pow(sectional_hydro_damping,2)/(wave_number*Breadth*Math.pow(alpha,2)),2)));
                FRF_Heave=Wave_Amplitude*eta* F;
                FRF_Pitch=Wave_Amplitude*eta* G;

                Vertical_Movement[i]=Math.sqrt(Math.pow(FRF_Heave,2) + Math.pow(FRF_Pitch,2)*Math.pow(position,2));
                Vertical_Acceleration[i]=Math.pow(alpha,2)*wave_number*g*Vertical_Movement[i];
                Pitch_Movement[i]=Math.sqrt(Math.pow(FRF_Pitch,2)*Math.pow(position,2));
                Heave_Movement[i]=Math.abs(FRF_Heave);

                //Bending Moment Response//

                Cb=Math.max(0.6,Block);    
                phi=2.5*(1-Cb);    
                F_Cb=(Math.pow(1-phi,2)+0.6*alpha*(2-phi));  

                F_v=1+3*Math.pow(Froude_N,2);    

                Bending_Moment[i]=Wave_Amplitude*(smith_factor*((1-wave_number*Draft)/(Math.pow(Length*eff_wave_number,2)))*(1-Math.cos(eff_wave_number*Length/2)-(eff_wave_number*Length/4)*Math.sin(eff_wave_number*Length/2))*F_v*F_Cb*Math.pow(Math.abs(Math.cos(betha)),1/3))*1025*g*W_Breadth*Length*Length/1000000;

			}
            
            ////// ROLL /////
            critical_damping_percentage = critical_damping_percentage/100;

            B_0 = W_Breadth;    
            Cb=Block;   
            restoring_moment_coeff = g*1025*Cb*Length*W_Breadth*Draft*GM;    
            
            for (i = 0; i &lt;= 1000; i++){
                
                wave_freq[i]=0.05+1.95*i/1000;
                wave_period[i]=2*3.14159/wave_freq[i];
                wave_number=Math.pow(wave_freq[i],2)/g;
 
                alpha=1-Froude_N*Math.sqrt(wave_number*Length)*Math.cos(betha);
                encounter_frequency =  wave_freq[i]*alpha;           
                eff_wave_number=Math.abs(wave_number*Math.cos(betha));
                
                breadth_ratio =  (Cwp - delta)/(1 - delta);
                B_1 = breadth_ratio*B_0;
                A_0 = Cb*B_0*Draft/(delta+breadth_ratio*(1-delta));
                A_1 = breadth_ratio*A_0;
                
                //sectional damping coefficient//
                Breadth_Draft_ratio = B_0/Draft;                                
                    //3 &amp;lt;= B/T &amp;lt;= 6//
                if (Breadth_Draft_ratio>3){
                    a0=0.256*Breadth_Draft_ratio - 0.286;
                    b0=-0.11*Breadth_Draft_ratio - 2.55;
                    d0=0.033*Breadth_Draft_ratio - 1.419;
                }
                
                    //1 &amp;lt;= B/T &amp;lt;= 3//
                else {
                    a0=-3.94*Breadth_Draft_ratio + 13.69;
                    b0=-2.12*Breadth_Draft_ratio - 1.89;
                    d0=1.16*Breadth_Draft_ratio-7.97;
                }
                
                Breadth_Draft_ratio = B_1/Draft;                                
                    //3 &amp;lt;= B/T &amp;lt;= 6//
                if (Breadth_Draft_ratio>3){
                    a1=0.256*Breadth_Draft_ratio - 0.286; 
                    b1=-0.11*Breadth_Draft_ratio - 2.55;
                    d1=0.033*Breadth_Draft_ratio - 1.419;
                }
                
                    //1 &amp;lt;= B/T &amp;lt;= 3//
                else {
                    a1=-3.94*Breadth_Draft_ratio + 13.69;
                    b1=-2.12*Breadth_Draft_ratio - 1.89;
                    d1=1.16*Breadth_Draft_ratio-7.97;
                }
               
                // console.log(B_0/Draft,B_1/Draft)
                //console.log(a0,a1)
                //B_44 - hydro damping coeff//
                b_44_0 = (1025*A_0*B_0*B_0*a0*Math.exp(b0*Math.pow(encounter_frequency,-1.3))*Math.pow(encounter_frequency,d0)/(Math.sqrt(B_0/(2*g))));
                b_44_1 = (1025*A_1*B_1*B_1*a1*Math.exp(b1*Math.pow(encounter_frequency,-1.3))*Math.pow(encounter_frequency,d1)/(Math.sqrt(B_1/(2*g))));
                
                damping_ratio=Math.sqrt(b_44_1/b_44_0);
                
                b_44 = Length*b_44_0*(delta + b_44_1*(1-delta)/b_44_0);
                //total damping = hydro damping + additional damping//
                
                add_damping = restoring_moment_coeff*natural_period/Math.PI;
                
                roll_hydro_damping= b_44 + add_damping*critical_damping_percentage;
                
                //excitation frequency//
                if (heading == 90  || heading ==270){
                excitation_frequency=Math.sqrt(1025*g*g*b_44_0/encounter_frequency)*(delta+damping_ratio*(1-delta))*Length
             
                }
                else{  
                    A=Math.abs(Math.sin(betha))*Math.sqrt(1025*g*g/encounter_frequency)*Math.sqrt(b_44_0)*2/eff_wave_number;
                    B=Math.pow(Math.sin(0.5*delta*Length*eff_wave_number),2);
                    C=Math.pow(damping_ratio*Math.sin(0.5*(1-delta)*Length*eff_wave_number),2);
                    D=2*damping_ratio*Math.sin(0.5*delta*Length*eff_wave_number)*Math.sin(0.5*(1-delta)*Length*eff_wave_number)*Math.cos(0.5*Length*eff_wave_number);

                    excitation_frequency=A*Math.sqrt(B+C+D)
                }
                
                //  excitation_frequency=Math.sqrt(1025*g*g*b_44_0/encounter_frequency)*(delta+damping_ratio*(1-delta))*Length; 
                //main formula//
                          
                A = Math.pow(-Math.pow(encounter_frequency*natural_period/(2*3.14159),2)+1,2);
                B = Math.pow(restoring_moment_coeff,2); 
                C = Math.pow(encounter_frequency*roll_hydro_damping,2); 
                
            
                Roll_Movement[i] = Wave_Amplitude*excitation_frequency/(Math.sqrt(A*B+C));
                //Roll_Movement[i] = Wave_Amplitude*excitation_frequency
                
            }
			
			//This "for()" receives the results from the motion vectors and prepare the graphics//
			
			for (i = 0; i &lt;= 1000; i++) 
			{
                Results_array1.push([wave_freq[i],Vertical_Movement[i]]);
                Results_array2.push([wave_freq[i],Vertical_Acceleration[i]]);
                Results_array3.push([wave_freq[i],Pitch_Movement[i]]);
                Results_array4.push([wave_freq[i],Heave_Movement[i]]);
                Results_array5.push([wave_freq[i],Bending_Moment[i]]);
                Results_array6.push([wave_freq[i],Roll_Movement[i]*180/Math.PI]);
                Results_array7.push([wave_period[i],Roll_Movement[i]*180/Math.PI]);
                
			}
    	
			Results = {"Vertical_Movement":Results_array1,"Vertical_Acceleration":Results_array2,"Pitch":Results_array3,"Heave":Results_array4,"Bending":Results_array5,"Roll":Results_array6};
            return Results;
    
}

    /**
     
 * @typedef {Object}Jensen
 * @property {Array} Vertical_Movement - Vertical Motion (m/m) per frequency(rad/s)
 * @property {Array} Vertical_Acceleration - Vertical Acceleration per frequency(rad/s)
 * @property {Array} Pitch - Pitch motion per frequency (rad/s)
 * @property {Array} Heave - Heave motion per frequency (rad/s)
 * @property {Array} Bending - Bending Moment per frequency(rad/s)
 * @property {Array} Roll - Roll motion per frequency(rad/s)
  * @example
 function FreqResponseShipMotion (Length,W_Breadth,Block,Draft,Speed,heading,Position,Wave_Amplitude,Cwp,GM,natural_period,critical_damping_percentage,delta){
        
    var wave_freq = [];
    var Vertical_Movement=[];
    var Vertical_Acceleration=[];
    var Pitch_Movement=[];
    var Heave_Movement=[];
    var Bending_Moment=[];
    var Roll_Movement=[];
    var wave_period=[];

    //Vector declaration in the the main function -- They receive the properties and are used to plot the curves//
    var Results_array1=[];
    var Results_array2=[];
    var Results_array3=[];
    var Results_array4=[];
    var Results_array5=[]; 
    var Results_array6=[];
    var Results_array7=[];	

    //These constants and variables are prepared to be used inside the "for()" that calculates the vessels motion responses 
    g=9.81;	
    betha=heading*Math.PI/180;

    Breadth = W_Breadth*Block;
    Speed_metric=Speed*0.5144444;
    Froude_N=Speed_metric/Math.sqrt((g*Length));
    position=Length*Position/200;

    //This "for()" calculates the vessel responses to different waves frequencies//

    for (i = 0; i &lt;= 1000; i++){
        wave_freq[i]=0.05+1.95*i/1000;
        wave_number=Math.pow(wave_freq[i],2)/g;
        eff_wave_number=Math.abs(wave_number*Math.cos(betha));
        smith_factor=Math.exp(-wave_number*Draft);
        alpha=1-Froude_N*Math.sqrt(wave_number*Length)*Math.cos(betha);
        sectional_hydro_damping=2*Math.sin(0.5*wave_number*Breadth*Math.pow(alpha,2))*Math.exp(-wave_number*Draft*Math.pow(alpha,2));
        a=Math.pow(1-wave_number*Draft,2);
        b=Math.pow((Math.pow(sectional_hydro_damping,2)/(wave_number*Breadth*Math.pow(alpha,3))),2);
        f=Math.sqrt(a+b);
        F=smith_factor*f*(2/(eff_wave_number*Length))*Math.sin(eff_wave_number*Length/2);
        G=smith_factor*f*(24/(Math.pow(eff_wave_number*Length,2)*Length))*(Math.sin(eff_wave_number*Length/2)-(eff_wave_number*Length/2)*Math.cos(eff_wave_number*Length/2));
        eta=1/(Math.sqrt(Math.pow((1-2*wave_number*Draft*Math.pow(alpha,2)),2)+Math.pow(Math.pow(sectional_hydro_damping,2)/(wave_number*Breadth*Math.pow(alpha,2)),2)));
        FRF_Heave=Wave_Amplitude*eta* F;
        FRF_Pitch=Wave_Amplitude*eta* G;

        Vertical_Movement[i]=Math.sqrt(Math.pow(FRF_Heave,2) + Math.pow(FRF_Pitch,2)*Math.pow(position,2));
        Vertical_Acceleration[i]=Math.pow(alpha,2)*wave_number*g*Vertical_Movement[i];
        Pitch_Movement[i]=Math.sqrt(Math.pow(FRF_Pitch,2)*Math.pow(position,2));
        Heave_Movement[i]=Math.abs(FRF_Heave);

        //Bending Moment Response//

        Cb=Math.max(0.6,Block);    
        phi=2.5*(1-Cb);    
        F_Cb=(Math.pow(1-phi,2)+0.6*alpha*(2-phi));  

        F_v=1+3*Math.pow(Froude_N,2);    

        Bending_Moment[i]=Wave_Amplitude*(smith_factor*((1-wave_number*Draft)/(Math.pow(Length*eff_wave_number,2)))*(1-Math.cos(eff_wave_number*Length/2)-(eff_wave_number*Length/4)*Math.sin(eff_wave_number*Length/2))*F_v*F_Cb*Math.pow(Math.abs(Math.cos(betha)),1/3))*1025*g*W_Breadth*Length*Length/1000000;

    }

    ////// ROLL /////
    critical_damping_percentage = critical_damping_percentage/100;

    B_0 = W_Breadth;    
    Cb=Block;   
    restoring_moment_coeff = g*1025*Cb*Length*W_Breadth*Draft*GM;    

    for (i = 0; i &lt;= 1000; i++){

        wave_freq[i]=0.05+1.95*i/1000;
        wave_period[i]=2*3.14159/wave_freq[i];
        wave_number=Math.pow(wave_freq[i],2)/g;

        alpha=1-Froude_N*Math.sqrt(wave_number*Length)*Math.cos(betha);
        encounter_frequency =  wave_freq[i]*alpha;           
        eff_wave_number=Math.abs(wave_number*Math.cos(betha));

        breadth_ratio =  (Cwp - delta)/(1 - delta);
        B_1 = breadth_ratio*B_0;
        A_0 = Cb*B_0*Draft/(delta+breadth_ratio*(1-delta));
        A_1 = breadth_ratio*A_0;

        //sectional damping coefficient//
        Breadth_Draft_ratio = B_0/Draft;                                
            //3 &amp;lt;= B/T &amp;lt;= 6//
        if (Breadth_Draft_ratio>3){
            a0=0.256*Breadth_Draft_ratio - 0.286;
            b0=-0.11*Breadth_Draft_ratio - 2.55;
            d0=0.033*Breadth_Draft_ratio - 1.419;
        }

            //1 &amp;lt;= B/T &amp;lt;= 3//
        else {
            a0=-3.94*Breadth_Draft_ratio + 13.69;
            b0=-2.12*Breadth_Draft_ratio - 1.89;
            d0=1.16*Breadth_Draft_ratio-7.97;
        }

        Breadth_Draft_ratio = B_1/Draft;                                
            //3 &amp;lt;= B/T &amp;lt;= 6//
        if (Breadth_Draft_ratio>3){
            a1=0.256*Breadth_Draft_ratio - 0.286; 
            b1=-0.11*Breadth_Draft_ratio - 2.55;
            d1=0.033*Breadth_Draft_ratio - 1.419;
        }

            //1 &amp;lt;= B/T &amp;lt;= 3//
        else {
            a1=-3.94*Breadth_Draft_ratio + 13.69;
            b1=-2.12*Breadth_Draft_ratio - 1.89;
            d1=1.16*Breadth_Draft_ratio-7.97;
        }

        // console.log(B_0/Draft,B_1/Draft)
        //console.log(a0,a1)
        //B_44 - hydro damping coeff//
        b_44_0 = (1025*A_0*B_0*B_0*a0*Math.exp(b0*Math.pow(encounter_frequency,-1.3))*Math.pow(encounter_frequency,d0)/(Math.sqrt(B_0/(2*g))));
        b_44_1 = (1025*A_1*B_1*B_1*a1*Math.exp(b1*Math.pow(encounter_frequency,-1.3))*Math.pow(encounter_frequency,d1)/(Math.sqrt(B_1/(2*g))));

        damping_ratio=Math.sqrt(b_44_1/b_44_0);

        b_44 = Length*b_44_0*(delta + b_44_1*(1-delta)/b_44_0);
        //total damping = hydro damping + additional damping//

        add_damping = restoring_moment_coeff*natural_period/Math.PI;

        roll_hydro_damping= b_44 + add_damping*critical_damping_percentage;

        //excitation frequency//
        if (heading == 90  || heading ==270){
        excitation_frequency=Math.sqrt(1025*g*g*b_44_0/encounter_frequency)*(delta+damping_ratio*(1-delta))*Length

        }
        else{  
            A=Math.abs(Math.sin(betha))*Math.sqrt(1025*g*g/encounter_frequency)*Math.sqrt(b_44_0)*2/eff_wave_number;
            B=Math.pow(Math.sin(0.5*delta*Length*eff_wave_number),2);
            C=Math.pow(damping_ratio*Math.sin(0.5*(1-delta)*Length*eff_wave_number),2);
            D=2*damping_ratio*Math.sin(0.5*delta*Length*eff_wave_number)*Math.sin(0.5*(1-delta)*Length*eff_wave_number)*Math.cos(0.5*Length*eff_wave_number);

            excitation_frequency=A*Math.sqrt(B+C+D)
        }

        //  excitation_frequency=Math.sqrt(1025*g*g*b_44_0/encounter_frequency)*(delta+damping_ratio*(1-delta))*Length; 
        //main formula//

        A = Math.pow(-Math.pow(encounter_frequency*natural_period/(2*3.14159),2)+1,2);
        B = Math.pow(restoring_moment_coeff,2); 
        C = Math.pow(encounter_frequency*roll_hydro_damping,2); 


        Roll_Movement[i] = Wave_Amplitude*excitation_frequency/(Math.sqrt(A*B+C));
        //Roll_Movement[i] = Wave_Amplitude*excitation_frequency

    }

    //This "for()" receives the results from the motion vectors and prepare the graphics//

    for (i = 0; i &lt;= 1000; i++) 
    {
        Results_array1.push([wave_freq[i],Vertical_Movement[i]]);
        Results_array2.push([wave_freq[i],Vertical_Acceleration[i]]);
        Results_array3.push([wave_freq[i],Pitch_Movement[i]]);
        Results_array4.push([wave_freq[i],Heave_Movement[i]]);
        Results_array5.push([wave_freq[i],Bending_Moment[i]]);
        Results_array6.push([wave_freq[i],Roll_Movement[i]*180/Math.PI]);
        Results_array7.push([wave_period[i],Roll_Movement[i]*180/Math.PI]);

    }


    Results = {"Vertical_Movement":Results_array1,"Vertical_Acceleration":Results_array2,"Pitch":Results_array3,"Heave":Results_array4,"Bending":Results_array5,"Roll":Results_array6};
    return Results;
    
}
*/



/**
 * @method */
/**
* This is a pure Holtrop function that takes speed as one of the parameters, and outputs a single rtotal value.
* It has been implemented with a memoization closure for parameters that will often remain fixed.
 * @param {number} lwl - Load Waterline Lenght.
 * @param {number} breadth  - Width at the widest point as measured at the ship's nominal waterline.
 * @param {number} tf  - Draft foreward.
 * @param {number} lcb - Longitudinal position of hull centre.
 * @param {number} cb - Block coefficient.
 * @param {number} csm - Midship Coefficient
 * @param {number} cwl - Construction waterline
 * @param {number} b - ???
 * @param {number} tr - Vertical distance from the bulbous section
centre to the keel line 
 * @param {number} cstern - ???
 * @param {number} app - Appendages
 * @param {number} area_app - Wetted surface of the appendages
 * @param {number} vs - Service speed
 * @returns {rtotal}
*/


var holtrop = function() {
	var parCache = {app:[], area_app:[]};
	
	//Environment (assumed static):
    var g = 9.81;
    var rho = 1025; // Water density (kg/m^3)
    var mi = 0.00122; // Kinematic viscosity of water (m^2/s)
	
	//Calculated values that can be reused when only changing speed:
	var wa, at, sapp, k2, volume, c1, c2, c5, c15, c17, m1, m3, lambda, rwa_0_4, rwb_0_55, hb, abt, pb, ca, k;
	
	return function (lwl, breadth, tf, ta, lcb, cb, csm, cwl, b, tr, cstern, app, area_app, vs) {
		//Check if any other parameters than speed are changed,
		//and update the parameters cache as needed:
		let mustUpdate = false;
		let pc = parsCache;
		if (pc.lwl !== lwl) {
			pc.lwl = lwl;
			mustUpdate = true;
		}
		if (breadth !== pc.breadth) {
			pc.breadth = breadth;
			mustUpdate = true;
		}
		if (tf !== pc.tf) {
			pc.tf = tf;
			mustUpdate = true;
		}
		if (ta !== pc.ta) {
			pc.ta = ta;
			mustUpdate = true;
		}
		if (lcb !== pc.lcb) {
			pc.lcb = lcb;
			mustUpdate = true;
		}
		if (cb !== pc.cb) {
			pc.cb = cb;
			mustUpdate = true;
		}
		if (csm !== pc.csm) {
			pc.csm = csm;
			mustUpdate = true;
		}
		if (cwl !== pc.cwl) {
			pc.cwl = cwl;
			mustUpdate = true;
		}
		if (b !== pc.b) {
			pc.b = b;
			mustUpdate = true;
		}
		if (tr !== pc.tr) {
			pc.tr = tr;
			mustUpdate = true;
		}
		if (cstern !== pc.cstern) {
			pc.cstern = cstern;
			mustUpdate = true;
		}
		if (app.length !== pc.app.length) {
			pc.app = app.slice();
			mustUpdate = true;
		} else {
			for (let i = 0; i &lt; app.length; i++) {
				if (app[i] !== pc.app[i]) {
					pc.app[i] = app[i];
					mustUpdate = true;
				}
			}
		}
		if (area_app.length !== pc.area_app.length) {
			pc.area_app = area_app.slice();
			mustUpdate = true;
		} else {
			for (let i = 0; i &lt; area_app.length; i++) {
				if (area_app[i] !== pc.area_app[i]) {
					pc.area_app[i] = area_app[i];
					mustUpdate = true;
				}
			}
		}
		
		//Do the following calculations only if other parameters than speed are changed:
		if (mustUpdate) {
			if ((lwl / breadth &lt; 3.9) || (lwl / breadth > 15)) {
				console.warn('The relation L/B is not being respected. It should be 3.9 &lt; L/B &lt; 15, not' + " " + Math.round(lwl / breadth * 10) / 10 + ".");
			}
			
			let total_area = 0;
			let mult = 0;

			// app[i] is the approximate 1+k2 value for the appendage of type 'i'. The appendages are arranged by type in the same order as presented in the 1982 paper by Holtrop &amp; Mennen.
			// area_app[i] is the surface area for the appendage of type 'i'.
			// it appears that the code requires that a 1+k2 value is entered for any appendages that are given ranges for the 1+k2 value in the '82 paper. The appendage types with a fixed value of 1+k2 are set to that value
			// this section of code needs to be looked at a bit closer

			// this loop sums the areas of the appendages, and sums the product of the individual appendage areas and individual appendage 1+k2 values.
			for (let i = 0; i &lt; (area_app).length; i++) {
				mult += app[i] * area_app[i];
				total_area += area_app[i];
			}

			// this section calculates the equivalent 1+k2 value for all appendages, if the total area is above 0.
			if (total_area !== 0) {

				k2 = mult / total_area;

			} else {

				k2 = 0;
			}

			sapp = total_area; // total appendage surface area
			let t = (ta + tf) / 2;; // calculates the mean draught
			if ((breadth / t &lt; 2.1) || (breadth / t > 4)) {
				console.warn('The relation B/T is not being respected. It should be 2.1 &lt; B/T &lt; 4, not' + " " + Math.round(breadth / t * 10) / 10 + ".");
			}
			
			volume = lwl * breadth * t * cb; // calculates the displaced volume
			
			// calculates the prismatic coefficient
			let cp = cb / csm;
			if ((cp &lt; 0.55) || (cp > 0.85)) {
				console.warn('The prismatic coefficient is not being respected. It should be 0.55 &lt; Cp &lt; 0.85, not' + " " + Math.round(cp * 100) / 100 + ".");
			}
			
			let lr = lwl * (1 - cp + (0.06 * cp * (lcb / 100) / (4 * cp - 1))); // approximates the 'length of run'
			hb = tf / 2; // approximates position of the centroid of the transverse bulb area above the keel line
			at = 0.95 * (ta - ta * 0.9225) * breadth * 0.89 * tr; // approximates the transom area
			abt = Math.PI * Math.pow(tf / 2, 2) * b / 7.7; // approximates the bulb area

			// Calculates coefficient c7 for use in the wave resistance calculation
			let c7;
			if (breadth / lwl &lt; 0.11) {

				c7 = 0.229577 * Math.pow(breadth / lwl, 0.33333);

			} else if (breadth / lwl &lt; 0.25) {

				c7 = breadth / lwl;

			} else {

				c7 = 0.5 - 0.0625 * lwl / breadth;

			}
			// Approximates the angle of entrance
			let ie = 1 + 89 * Math.exp(-Math.pow(lwl / breadth, 0.80856) * Math.pow(1 - cwl, 0.30484) * Math.pow(1 - cp - 0.0225 * (lcb / 100), 0.6367) * Math.pow(lr / breadth, 0.34574) * Math.pow(100 * (volume / Math.pow(lwl, 3)), 0.16302)); // calculate the half angle of entrance
			// Calculates coefficient c1 
			c1 = 2223105 * Math.pow(c7, 3.78613) * Math.pow(t / breadth, 1.07961) * Math.pow(90 - ie, -1.37565);
			// Calculates coefficient c3 
			let c3 = 0.56 * (Math.pow(abt, 1.5)) / (breadth * t * (0.31 * Math.pow(abt, 0.5) + tf - hb));
			// Calculates coefficient c2 
			c2 = Math.exp(-1.89 * Math.pow(c3, 0.5));
			// Calculates coefficient c4
			let c4;
			if (tf / lwl > 0.04) {
				c4 = 0.04;
			} else {
				c4 = tf / lwl;
			}

			// Calculates coefficient c5
			c5 = 1 - (0.8 * at) / (breadth * t * csm);

			// Calculates coefficient c14
			let c14;
			if (cstern === 1) {

				c14 = 1 + 0.011 * (-25);

			} else if (cstern === 2) {

				c14 = 1 + 0.011 * (-10);

			} else if (cstern === 3) {

				c14 = 1 + 0.011 * (0);

			} else {

				c14 = 1 + 0.011 * 10;
			}

			// Calculates coefficient c15
			if (Math.pow(lwl, 3) / volume &lt; 512) {

				c15 = -1.69385;

			} else if (Math.pow(lwl, 3) / volume &lt; 1726.91) {

				c15 = -1.69385 + (lwl / Math.pow(volume, 1 / 3) - 8) / 2.36;

			} else {

				c15 = 0;

			}

			// Calculates coefficient c16
			let c16;
			if (cp &lt; 0.8) {

				c16 = 8.07981 * cp - 13.8673 * Math.pow(cp, 2) + 6.984388 * Math.pow(cp, 3);

			} else {

				c16 = 1.73014 - 0.7067 * cp;

			}

			// Calculates coefficient c17
			c17 = 6919.3 * Math.pow(csm, -1.3346) * Math.pow(volume / Math.pow(lwl, 3), 2.00977) * Math.pow(lwl / breadth - 2, 1.40692);
			// Calculates correlation allowance coefficient 
			ca = 0.006 * Math.pow(lwl + 100, -0.16) - 0.00205 + 0.003 * Math.pow(lwl / 7.5, 0.5) * Math.pow(cb, 4) * c2 * (0.04 - c4);
			// Approximates wetted surface area
			wa = lwl * (2 * t + breadth) * Math.pow(csm, 0.5) * (0.453 + 0.4425 * cb - 0.2862 * csm - 0.003467 * (breadth / t) + 0.3696 * cwl) + (2.38 * abt) / cb; // wetted area
			// Calculates coefficient m1
			m1 = 0.0140407 * (lwl / t) - 1.75254 * ((Math.pow(volume, 1 / 3)) / lwl) - 4.79323 * (breadth / lwl) - c16;
			// Calculates coefficient m3
			m3 = -7.2035 * Math.pow(breadth / lwl, 0.326869) * Math.pow(t / breadth, 0.605375);
			// Calculates lambda
			if (lwl / breadth > 12) {

				lambda = 1.446 * cp - 0.36;

			} else {

				lambda = 1.446 * cp - 0.03 * (lwl / breadth);

			}
			// Calculates coefficient Pb - a measure for the emergence of the bow
			pb = (0.56 * Math.pow(abt, 0.5)) / (tf - 1.5 * hb);
			// Calculates coefficient m4 for the Fn &lt; 0.4 wave prediction
			let m4_0_4 = c15 * 0.4 * Math.exp(-0.034 * Math.pow(0.4, -3.29));
			// Calculates coefficient m4 for the Fn > 0.55 wave prediction
			let m4_0_55 = c15 * 0.4 * Math.exp(-0.034 * Math.pow(0.55, -3.29));
			// Calculates the wave resistance below Fn=0.4 - 1984 version
			rwa_0_4 = c1 * c2 * c5 * volume * rho * g * Math.exp(m1 * Math.pow(0.4, -0.9) + m4_0_4 * Math.cos(lambda * Math.pow(0.4, -2)));
			// Calculates the wave resistance above Fn=0.55 - 1984 version
			rwb_0_55 = c17 * c2 * c5 * volume * rho * g * Math.exp(m3 * Math.pow(0.55, -0.9) + m4_0_55 * Math.cos(lambda * Math.pow(0.55, -2)));
			// Calculates the canoe body form factor - 1984 version
			k = 0.93 + (0.487118 * c14 * Math.pow(breadth / lwl, 1.06806) * Math.pow(t / lwl, 0.46106) * Math.pow(lwl / lr, 0.121563) * Math.pow(Math.pow(lwl, 3) / volume, 0.36486) * Math.pow(1 - cp, -0.604247)); // form factor
		}
		
		//////////////////////////////////////////////////////
		//// CALCULATIONS THAT DEPEND ON SPEED START HERE ////
		//////////////////////////////////////////////////////	
		let vsm = 0.514444*vs; // Convert the speed from knots to m/s
		let fn = vsm / Math.pow(g * lwl, 0.5); // Calculates Froude number

		let re = rho * lwl * vsm / mi; // Calculates Reynolds number

		let cf = 0.075 / Math.pow((Math.log(re) / Math.log(10)) - 2, 2); // Calculates friction coefficient using the ITTC formula

		let rf = 0.5 * rho * Math.pow(vsm, 2) * wa * cf; // Calculates frictional resistance

		// This conditional statement calculates the Froude Number based on transom immersion
		let fnt;
		if (at === 0 ) fnt = 0;
		else fnt = vsm / (Math.pow((2 * g * at) / (breadth + breadth * cwl), 0.5));

		let c6;
		if (fnt &lt; 5) c6 = 0.2 * (1 - 0.2 * fnt);
		else c6 = 0;
		
		let rtr = 0.5 * rho * Math.pow(vsm, 2) * at * c6; // Transom pressure resistance

		let rapp = 0.5 * rho * Math.pow(vsm, 2) * sapp * (k2) * cf; // Appendage resistance
	 
		let m4, rwa, rwb, rwab;
		if (fn === 0) {
			// Sets resistance to zero if Fn=0
			m4 = 0;
			rwa = 0;
			rwb = 0;
			rwab = 0;
		} else {
			// Calculates all three Fn based resistance values when Fn does not = 0
			m4 = c15 * 0.4 * Math.exp(-0.034 * Math.pow(fn, -3.29));

			rwa = c1 * c2 * c5 * volume * rho * g * Math.exp(m1 * Math.pow(fn, -0.9) + m4 * Math.cos(lambda * Math.pow(fn, -2))); // wave resistance for Froude &lt; 0.4

			rwb = c17 * c2 * c5 * volume * rho * g * Math.exp(m3 * Math.pow(fn, -0.9) + m4 * Math.cos(lambda * Math.pow(fn, -2))); // wave resistance for Froude > 0.55

			rwab = rwa_0_4 + (10 * fn - 4) * (rwb_0_55 - rwa_0_4) / 1.5;
		}
		
		// Calculates Fn based on bulb immersion
		let fni = vsm / Math.sqrt(g * (tf - hb - 0.25 * Math.pow(abt, 0.5)) + (0.15 * Math.pow(vsm, 2)));

		// Sets resistance value to the correct value calculated on lines 289-299, based on the actual Fn
		let rw;
		if (fn &lt; 0.4) rw = rwa;
		else if (fn &lt; 0.55) rw = rwab;
		else rw = rwb;
		
		// Sets bulb resistance to zero if transverse bulb area =0
		let rb;
		if (abt === 0) rb = 0;
		// Calculates bulb resistance for any non-zero transverse bulb area
		else rb = (0.11 * Math.exp(-3 * Math.pow(pb, -2)) * Math.pow(fni, 3) * Math.pow(abt, 1.5) * rho * g) / (1 + Math.pow(fni, 2));
		
		// Calculates model-ship correlation resistance
		let ra = 0.91 * 0.5 * rho * Math.pow(vsm, 2) * wa * ca;

		// Calculates total resistance
		let rtotal = (k * rf + rapp + rw + rb + rtr + ra) / 1000;
		
		return rtotal;
	};
}
/**
* @class rtotal
* calculates total resistance
* @param {number} k - Canoe body form factor - 1984 version
* @param {number} rf -  Frictional resistance 
* @param {number} rapp - Appendage resistance
* @param {number} rw - Corrected resistance value
* @param {number} rb - Bulb resistance
* @param {number} rtr - Transformed pressure resistance
* @param {number} ra - Model-ship correlation resistance
*/
var rtotal = (k * rf + rapp + rw + rb + rtr + ra) / 1000;

/**
 * @method */
/**
* This is a pure function that does the Holtrop calculations that are invariant with speed, and returns a function of speed that calculates fn and rtotal. The generated function can be used for efficiently calculating the resistance without concerns for invariant parameters.
* It has been implemented with a memoization closure for parameters that will often remain fixed.
 * @param {number} lwl - Load Waterline Lenght.
 * @param {number} breadth  - Width at the widest point as measured at the ship's nominal waterline.
 * @param {number} tf  - Draft foreward.
 * @param {number} lcb - Longitudinal position of hull centre.
 * @param {number} cb - Block coefficient.
 * @param {number} csm - Midship Coefficient
 * @param {number} cwl - Construction waterline
 * @param {number} b - ???
 * @param {number} tr - Vertical distance from the bulbous section
centre to the keel line 
 * @param {number} cstern - ???
 * @param {number} app - Appendages
 * @param {number} area_app - Wetted surface of the appendages
 * @param {number} vs - Service speed
 * @returns {rtotal}
 * @returns {fn}
*/
function getHoltropFunction(lwl, breadth, tf, ta, lcb, cb, csm, cwl, b, tr, cstern, app, area_app) {
	//Environment (assumed static):
    var g = 9.81;
    var rho = 1025; // Water density (kg/m^3)
    var mi = 0.00122; // Kinematic viscosity of water (m^2/s)

	if ((lwl / breadth &lt; 3.9) || (lwl / breadth > 15)) {
		console.warn('The relation L/B is not being respected. It should be 3.9 &lt; L/B &lt; 15, not' + " " + Math.round(lwl / breadth * 10) / 10 + ".");
	}
	
	let total_area = 0;
	let mult = 0;

	// app[i] is the approximate 1+k2 value for the appendage of type 'i'. The appendages are arranged by type in the same order as presented in the 1982 paper by Holtrop &amp; Mennen.
	// area_app[i] is the surface area for the appendage of type 'i'.
	// it appears that the code requires that a 1+k2 value is entered for any appendages that are given ranges for the 1+k2 value in the '82 paper. The appendage types with a fixed value of 1+k2 are set to that value
	// this section of code needs to be looked at a bit closer

	// this loop sums the areas of the appendages, and sums the product of the individual appendage areas and individual appendage 1+k2 values.
	for (let i = 0; i &lt; (area_app).length; i++) {
		mult += app[i] * area_app[i];
		total_area += area_app[i];
	}

	// this section calculates the equivalent 1+k2 value for all appendages, if the total area is above 0.
	let k2;
	if (total_area !== 0) {

		k2 = mult / total_area;

	} else {

		k2 = 0;
	}

	let sapp = total_area; // total appendage surface area
	let t = (ta + tf) / 2;; // calculates the mean draught
	if ((breadth / t &lt; 2.1) || (breadth / t > 4)) {
		console.warn('The relation B/T is not being respected. It should be 2.1 &lt; B/T &lt; 4, not' + " " + Math.round(breadth / t * 10) / 10 + ".");
	}
	
	let volume = lwl * breadth * t * cb; // calculates the displaced volume
	
	// calculates the prismatic coefficient
	let cp = cb / csm;
	if ((cp &lt; 0.55) || (cp > 0.85)) {
		console.warn('The prismatic coefficient is not being respected. It should be 0.55 &lt; Cp &lt; 0.85, not' + " " + Math.round(cp * 100) / 100 + ".");
	}
	
	let lr = lwl * (1 - cp + (0.06 * cp * (lcb / 100) / (4 * cp - 1))); // approximates the 'length of run'
	let hb = tf / 2; // approximates position of the centroid of the transverse bulb area above the keel line
	let at = 0.95 * (ta - ta * 0.9225) * breadth * 0.89 * tr; // approximates the transom area
	let abt = Math.PI * Math.pow(tf / 2, 2) * b / 7.7; // approximates the bulb area

	// Calculates coefficient c7 for use in the wave resistance calculation
	let c7;
	if (breadth / lwl &lt; 0.11) {

		c7 = 0.229577 * Math.pow(breadth / lwl, 0.33333);

	} else if (breadth / lwl &lt; 0.25) {

		c7 = breadth / lwl;

	} else {

		c7 = 0.5 - 0.0625 * lwl / breadth;

	}
	// Approximates the angle of entrance
	let ie = 1 + 89 * Math.exp(-Math.pow(lwl / breadth, 0.80856) * Math.pow(1 - cwl, 0.30484) * Math.pow(1 - cp - 0.0225 * (lcb / 100), 0.6367) * Math.pow(lr / breadth, 0.34574) * Math.pow(100 * (volume / Math.pow(lwl, 3)), 0.16302)); // calculate the half angle of entrance
	// Calculates coefficient c1 
	let c1 = 2223105 * Math.pow(c7, 3.78613) * Math.pow(t / breadth, 1.07961) * Math.pow(90 - ie, -1.37565);
	// Calculates coefficient c3 
	let c3 = 0.56 * (Math.pow(abt, 1.5)) / (breadth * t * (0.31 * Math.pow(abt, 0.5) + tf - hb));
	// Calculates coefficient c2 
	let c2 = Math.exp(-1.89 * Math.pow(c3, 0.5));
	// Calculates coefficient c4
	let c4;
	if (tf / lwl > 0.04) {
		c4 = 0.04;
	} else {
		c4 = tf / lwl;
	}

	// Calculates coefficient c5
	let c5 = 1 - (0.8 * at) / (breadth * t * csm);

	// Calculates coefficient c14
	let c14;
	if (cstern === 1) {

		c14 = 1 + 0.011 * (-25);

	} else if (cstern === 2) {

		c14 = 1 + 0.011 * (-10);

	} else if (cstern === 3) {

		c14 = 1 + 0.011 * (0);

	} else {

		c14 = 1 + 0.011 * 10;
	}

	// Calculates coefficient c15
	let c15;
	if (Math.pow(lwl, 3) / volume &lt; 512) {

		c15 = -1.69385;

	} else if (Math.pow(lwl, 3) / volume &lt; 1726.91) {

		c15 = -1.69385 + (lwl / Math.pow(volume, 1 / 3) - 8) / 2.36;

	} else {

		c15 = 0;

	}

	// Calculates coefficient c16
	let c16;
	if (cp &lt; 0.8) {

		c16 = 8.07981 * cp - 13.8673 * Math.pow(cp, 2) + 6.984388 * Math.pow(cp, 3);

	} else {

		c16 = 1.73014 - 0.7067 * cp;

	}

	// Calculates coefficient c17
	let c17 = 6919.3 * Math.pow(csm, -1.3346) * Math.pow(volume / Math.pow(lwl, 3), 2.00977) * Math.pow(lwl / breadth - 2, 1.40692);
	// Calculates correlation allowance coefficient 
	let ca = 0.006 * Math.pow(lwl + 100, -0.16) - 0.00205 + 0.003 * Math.pow(lwl / 7.5, 0.5) * Math.pow(cb, 4) * c2 * (0.04 - c4);
	// Approximates wetted surface area
	let wa = lwl * (2 * t + breadth) * Math.pow(csm, 0.5) * (0.453 + 0.4425 * cb - 0.2862 * csm - 0.003467 * (breadth / t) + 0.3696 * cwl) + (2.38 * abt) / cb; // wetted area
	// Calculates coefficient m1
	let m1 = 0.0140407 * (lwl / t) - 1.75254 * ((Math.pow(volume, 1 / 3)) / lwl) - 4.79323 * (breadth / lwl) - c16;
	// Calculates coefficient m3
	let m3 = -7.2035 * Math.pow(breadth / lwl, 0.326869) * Math.pow(t / breadth, 0.605375);
	// Calculates lambda
	let lambda;
	if (lwl / breadth > 12) {

		lambda = 1.446 * cp - 0.36;

	} else {

		lambda = 1.446 * cp - 0.03 * (lwl / breadth);

	}
	// Calculates coefficient Pb - a measure for the emergence of the bow
	let pb = (0.56 * Math.pow(abt, 0.5)) / (tf - 1.5 * hb);
	// Calculates coefficient m4 for the Fn &lt; 0.4 wave prediction
	let m4_0_4 = c15 * 0.4 * Math.exp(-0.034 * Math.pow(0.4, -3.29));
	// Calculates coefficient m4 for the Fn > 0.55 wave prediction
	let m4_0_55 = c15 * 0.4 * Math.exp(-0.034 * Math.pow(0.55, -3.29));
	// Calculates the wave resistance below Fn=0.4 - 1984 version
	let rwa_0_4 = c1 * c2 * c5 * volume * rho * g * Math.exp(m1 * Math.pow(0.4, -0.9) + m4_0_4 * Math.cos(lambda * Math.pow(0.4, -2)));
	// Calculates the wave resistance above Fn=0.55 - 1984 version
	let rwb_0_55 = c17 * c2 * c5 * volume * rho * g * Math.exp(m3 * Math.pow(0.55, -0.9) + m4_0_55 * Math.cos(lambda * Math.pow(0.55, -2)));
	// Calculates the canoe body form factor - 1984 version
	let k = 0.93 + (0.487118 * c14 * Math.pow(breadth / lwl, 1.06806) * Math.pow(t / lwl, 0.46106) * Math.pow(lwl / lr, 0.121563) * Math.pow(Math.pow(lwl, 3) / volume, 0.36486) * Math.pow(1 - cp, -0.604247)); // form factor
	
	//Returns function of speed vs (knots) that gives total resistance
	return function(vs) {
		//////////////////////////////////////////////////////
		//// CALCULATIONS THAT DEPEND ON SPEED START HERE ////
		//////////////////////////////////////////////////////	
		let vsm = 0.514444*vs; // Convert the speed from knots to m/s
		let fn = vsm / Math.pow(g * lwl, 0.5); // Calculates Froude number

		let re = rho * lwl * vsm / mi; // Calculates Reynolds number

		let cf = 0.075 / Math.pow((Math.log(re) / Math.log(10)) - 2, 2); // Calculates friction coefficient using the ITTC formula

		let rf = 0.5 * rho * Math.pow(vsm, 2) * wa * cf; // Calculates frictional resistance

		// This conditional statement calculates the Froude Number based on transom immersion
		let fnt;
		if (at === 0 ) fnt = 0;
		else fnt = vsm / (Math.pow((2 * g * at) / (breadth + breadth * cwl), 0.5));

		let c6;
		if (fnt &lt; 5) c6 = 0.2 * (1 - 0.2 * fnt);
		else c6 = 0;
		
		let rtr = 0.5 * rho * Math.pow(vsm, 2) * at * c6; // Transom pressure resistance

		let rapp = 0.5 * rho * Math.pow(vsm, 2) * sapp * (k2) * cf; // Appendage resistance
	 
		let m4, rwa, rwb, rwab;
		if (fn === 0) {
			// Sets resistance to zero if Fn=0
			m4 = 0;
			rwa = 0;
			rwb = 0;
			rwab = 0;
		} else {
			// Calculates all three Fn based resistance values when Fn does not = 0
			m4 = c15 * 0.4 * Math.exp(-0.034 * Math.pow(fn, -3.29));

			rwa = c1 * c2 * c5 * volume * rho * g * Math.exp(m1 * Math.pow(fn, -0.9) + m4 * Math.cos(lambda * Math.pow(fn, -2))); // wave resistance for Froude &lt; 0.4

			rwb = c17 * c2 * c5 * volume * rho * g * Math.exp(m3 * Math.pow(fn, -0.9) + m4 * Math.cos(lambda * Math.pow(fn, -2))); // wave resistance for Froude > 0.55

			rwab = rwa_0_4 + (10 * fn - 4) * (rwb_0_55 - rwa_0_4) / 1.5;
		}
		
		// Calculates Fn based on bulb immersion
		let fni = vsm / Math.sqrt(g * (tf - hb - 0.25 * Math.pow(abt, 0.5)) + (0.15 * Math.pow(vsm, 2)));

		// Sets resistance value to the correct value calculated on lines 289-299, based on the actual Fn
		let rw;
		if (fn &lt; 0.4) rw = rwa;
		else if (fn &lt; 0.55) rw = rwab;
		else rw = rwb;
		
		// Sets bulb resistance to zero if transverse bulb area =0
		let rb;
		if (abt === 0) rb = 0;
		// Calculates bulb resistance for any non-zero transverse bulb area
		else rb = (0.11 * Math.exp(-3 * Math.pow(pb, -2)) * Math.pow(fni, 3) * Math.pow(abt, 1.5) * rho * g) / (1 + Math.pow(fni, 2));
		
		// Calculates model-ship correlation resistance
		let ra = 0.91 * 0.5 * rho * Math.pow(vsm, 2) * wa * ca;
		
		// Calculates total resistance
		let rtotal = (k * rf + rapp + rw + rb + rtr + ra) / 1000;
		
		//Output. This can be extended indefinitely.
		return {
			fn: fn,
			rtotal: rtotal
		};
	};
}
/**
* @class fn
* Froud Number
* @param {number} vsm - Converted speed, from knots to m/s
* @param {number} g -  Gravity
* @param {number} lwl - Load Waterline Lenght

*/
let fn = vsm / Math.pow(g * lwl, 0.5); // Calculates Froude number</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Azimuth.html">Azimuth</a></li><li><a href="baseObjects.html">baseObjects</a></li><li><a href="baseObjects_affiliations.html">affiliations</a></li><li><a href="baseObjects_boxDimensions.html">boxDimensions</a></li><li><a href="baseObjects_capabilities.html">capabilities</a></li><li><a href="baseObjects_cost.html">cost</a></li><li><a href="baseObjects_weight.html">weight</a></li><li><a href="calculations.html">calculations</a></li><li><a href="fn.html">fn</a></li><li><a href="MainPropeller.html">MainPropeller</a></li><li><a href="objects.html">objects</a></li><li><a href="objects_position.html">position</a></li><li><a href="Propeller.html">Propeller</a></li><li><a href="rtotal.html">rtotal</a></li><li><a href="Rudder.html">Rudder</a></li><li><a href="TunnelThruster.html">TunnelThruster</a></li><li><a href="vessel.html">vessel</a></li><li><a href="vessel_attributes.html">attributes</a></li><li><a href="vessel_bulkheads.html">bulkheads</a></li><li><a href="vessel_structure.html">structure</a></li></ul><h3>Global</h3><ul><li><a href="global.html#FreqResponseShipMotion">FreqResponseShipMotion</a></li><li><a href="global.html#getHoltropFunction">getHoltropFunction</a></li><li><a href="global.html#holtrop">holtrop</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.1</a> on Thu Jul 13 2017 12:33:53 GMT+0200 (Romance Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
